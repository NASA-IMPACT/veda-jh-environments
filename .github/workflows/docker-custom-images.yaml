name: docker-custom-images

on:
  push:
    branches:
      - main

jobs:
  build-custom-images:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: azure/setup-helm@v3

#      - name: set git rev-parse head
#        id: commitsha_head
#        run: |
#          TEMP=$(git rev-parse HEAD)
#          echo "GIT_REV_HEAD=$TEMP" >> $GITHUB_OUTPUT
#
#      - name: configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v1
#        with:
#          aws-access-key-id: ${{ secrets.DEPLOY_USER_AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.DEPLOY_USER_AWS_SECRET_ACCESS_KEY }}
#          aws-region: us-east-1
#
#      - name: docker build, tag, and push custom images
#        env:
#          ECR_REGISTRY_CUSTOM: public.ecr.aws/i8x6m1u9/tf-eis-feds-nrt-west1-sandbox
#        run: |
#          #####################
#          # TODO: for this to be viable the deploy user needs to have correct permission via TF to do the following via awscli:
#          # 0. create_repository
#          # 1. describe_repositories
#          # 2. describe_images, describe_images_tags
#          # 3. set_repository_policies, put_lifecycle_policies
#          # custom pangeo-notebook image
#
#          pushd ./docker-images/custom/eis-feds-nrt
#          VERSION=$(cat Dockerfile | grep VERSION | cut -d'=' -f 2)
#          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws
#          docker build -t $ECR_REGISTRY_CUSTOM:$VERSION .
#          docker push $ECR_REGISTRY_CUSTOM:$VERSION
#          popd
#
#      - name: download jupyterhub/jupyterhub helm version
#        id: download_helm
#        run: |
#          #####################
#          # this downloads the version of jupyterhub we already use on the k8s cluster
#          # 1) untars it to ./jupyterhub directory
#          # 2) exposes the templates we will need later to run individually and template manifests
#          rm -rf ./jupyterhub
#          helm repo add jupyterhub https://jupyterhub.github.io/helm-chart/
#          helm pull jupyterhub/jupyterhub --version=2.0.0 --debug --untar
#
#      - name: copy all dockerfiles to helm chart
#        id: copydockerfiles
#        run: |
#          #####################
#          # set up the downstream steps for helm
#          rm -rf ./jupyterhub/dockerfile_inputs
#          cp -r ./docker-images/custom ./jupyterhub/dockerfile_inputs
#          TEMP=$(ls -lah ./jupyterhub/dockerfile_inputs)
#          echo $TEMP
##
#      - name: find all dockerfiles && helm template manifest for daemon continuous-imagepuller
#        id: valuesfile
#        env:
#          ECR_REGISTRY_CUSTOM: public.ecr.aws/i8x6m1u9/tf-eis-feds-nrt-west1-sandbox
#        run: |
#          #####################
#          # get a list of all dockerfiles but the paths must be relative to the helm chart
#          # and exclude the base images we don't want to use
#          pushd ./jupyterhub
#          DOCKERFILES=$(find dockerfile_inputs/* -name "Dockerfile" ! -path '*/base/*' ! -path '*/examples/*' -prune)
#
#          #####################
#          # build a small $PROFILE_VALUES file with our custom images we want to use
#          PROFILE_VALUES=profilelist.yaml
#          INDEX=0
#          printf "  profileList:\n" >> $PROFILE_VALUES
#          while read DOCKERFILE_PATH; do
#            VERSION=$(cat $DOCKERFILE_PATH | grep VERSION | cut -d'=' -f 2)
#            NAME_AND_DESC=$(echo $DOCKERFILE_PATH | cut -d'/' -f 2)
#            printf "    - display-name: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
#            printf "      description: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
#            printf "      kubespawner_override:\n"  >> $PROFILE_VALUES
#            printf "        image: $ECR_REGISTRY_CUSTOM:$VERSION\n"  >> $PROFILE_VALUES
#            if [ $INDEX -eq 0 ]; then
#            printf "      default: true\n"  >> $PROFILE_VALUES
#            fi
#            let INDEX=${INDEX}+1
#          done < <(echo "$DOCKERFILES")
#          #cat $PROFILE_VALUES
#
#          #####################
#          # we want to take our custom $PROFILE_VALUES file and substitute it into the correct
#          # jupyterhub values.yaml spot through a series of edits
#          START_VALUES=values.yaml
#          NEW_VALUES=new-values.yaml
#
#          # find the existing empty "profileList" number
#          LINE_TO_DELETE=$(cat "$START_VALUES" | grep -n profileList | cut -d':' -f1)
#
#          # create $NEW_VALUES file with our custom $PROFILE_LIST file values by:
#          # 1) finding "/profileList/" in $START_VALUES file and get line number match
#          # 2) and insert everything from $PROFILE_VALUES file after that match line
#          sed -e '/profileList/r./'"$PROFILE_VALUES"'' $START_VALUES > $NEW_VALUES
#
#          # delete the first (and pre-existing) empty 'profileList' line
#          sed -i ''"$LINE_TO_DELETE"'d' $NEW_VALUES
#
#          # QC check in CI/CD runner
#          cat $NEW_VALUES | grep -B 15 -A 10 profileList
#
#          ######################
#          # helm render only the template we care about deploying which the daemonset
#          helm template -s templates/image-puller/daemonset-continuous.yaml . -f new-values.yaml > ../gitops-deploy/manifests.yaml
#
#          # QC check in CI/CD runner
#          cat ../gitops-deploy/manifests.yaml
#
#          # don't want github actions bot committing this
#          popd
#          rm -rf ./jupyterhub
#
#          ######################
#          # TODO: add yaml validator step
#
#      - name: commit ./gitops-deploy changes back
#        uses: EndBug/add-and-commit@v7
#        with:
#          default_author: github_actions
