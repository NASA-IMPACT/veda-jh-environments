name: docker-custom-images

on:
  push:
    branches:
      - main

jobs:
  build-custom-images:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: azure/setup-helm@v3

      - uses: sergeysova/jq-action@v2

      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.DEPLOY_USER_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEPLOY_USER_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: docker build, tag, and push custom images
        run: |
          # get a list of all custom Dockerfiles
          DOCKERFILES=$(find ./docker-images/custom/* -name "Dockerfile")

          #####################
          # loop through and build ony if image doesn't exist on remote with our tags
          while read DOCKERFILE_PATH; do
            VERSION=$(cat $DOCKERFILE_PATH | grep VERSION | cut -d'=' -f 2)
            NAME_AND_DESC=$(echo $DOCKERFILE_PATH | cut -d'/' -f 4)
            PARENT_DIR=$(echo $DOCKERFILE_PATH | xargs -I{} dirname {})

            # check if repo does not exist
            existing_repo_uri=$(aws ecr-public describe-repositories | jq '.repositories | map(.repositoryUri)' | grep "$NAME_AND_DESC" | xargs)
            echo "###################################"
            echo "FOUND EXISTING REPO: $existing_repo_uri"
            echo "###################################"
            if [[ -z "$existing_repo_uri" ]]; then
              aws ecr-public create-repository \
                --repository-name "$NAME_AND_DESC" \
                --catalog-data=description='veda-custom-image',architectures='x86-64',operatingSystems='Linux' \
                --tags=Key='org',Value='NASA' \
                --tags=Key='project',Value='VEDA'

              # now get the URI again so we can use it when we build
              existing_repo_uri=$(aws ecr-public describe-repositories | jq '.repositories | map(.repositoryUri)' | grep "$NAME_AND_DESC" | xargs)
            fi

            # check if image with correct tags does not exist
            DOCKERFILE_DIGEST=$(sha256sum "$DOCKERFILE_PATH" | cut -d' ' -f1)
            image_exists=$(aws ecr-public describe-images --repository-name "$NAME_AND_DESC" --image-ids=imageTag="$VERSION" | jq '.imageDetails | map(.repositoryName)' | grep "$NAME_AND_DESC" | xargs)
            echo "###################################"
            echo "FOUND EXISTING IMAGE WITH TAG: $image_exists > $VERSION"
            echo "###################################"
            if [ -z "$image_exists" ]; then
              echo "###################################"
              echo "BUILDING CUSTOM IMAGE..."
              echo "###################################"
              pushd $PARENT_DIR
              # login
              aws ecr-public get-login-password | docker login --username AWS --password-stdin public.ecr.aws

              # build image
              docker build -t $existing_repo_uri:$VERSION .

              # push image to ECR
              docker push $existing_repo_uri:$VERSION
              popd
            fi
          done < <(echo "$DOCKERFILES")

#      - name: download jupyterhub/jupyterhub helm version
#        id: download_helm
#        run: |
#          #####################
#          # this downloads the version of jupyterhub we already use on the k8s cluster
#          # 1) untars it to ./jupyterhub directory
#          # 2) exposes the templates we will need later to run individually and template manifests
#          rm -rf ./jupyterhub
#          helm repo add jupyterhub https://jupyterhub.github.io/helm-chart/
#          helm pull jupyterhub/jupyterhub --version=2.0.0 --debug --untar
#
#      - name: copy all dockerfiles to helm chart
#        id: copydockerfiles
#        run: |
#          #####################
#          # set up the downstream steps for helm
#          rm -rf ./jupyterhub/dockerfile_inputs
#          cp -r ./docker-images/custom ./jupyterhub/dockerfile_inputs
#          TEMP=$(ls -lah ./jupyterhub/dockerfile_inputs)
#          echo $TEMP
#
#      - name: find all dockerfiles && helm template manifest for daemon continuous-imagepuller
#        id: valuesfile
#        run: |
#          #####################
#          # get a list of all dockerfiles but the paths must be relative to the helm chart
#          # and exclude the custom images we don't want to use
#          pushd ./jupyterhub
#          DOCKERFILES=$(find dockerfile_inputs/* -name "Dockerfile" ! -path '*/base/*' ! -path '*/examples/*' -prune)
#
#          #####################
#          # build a small $PROFILE_VALUES file with our custom images we want to use
#          PROFILE_VALUES=profilelist.yaml
#          INDEX=0
#          printf "  profileList:\n" >> $PROFILE_VALUES
#          while read DOCKERFILE_PATH; do
#            VERSION=$(cat $DOCKERFILE_PATH | grep VERSION | cut -d'=' -f 2)
#            NAME_AND_DESC=$(echo $DOCKERFILE_PATH | cut -d'/' -f 2)
#            printf "    - display-name: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
#            printf "      description: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
#            printf "      kubespawner_override:\n"  >> $PROFILE_VALUES
#            printf "        image: $ECR_REGISTRY_CUSTOM:$VERSION\n"  >> $PROFILE_VALUES
#            if [ $INDEX -eq 0 ]; then
#            printf "      default: true\n"  >> $PROFILE_VALUES
#            fi
#            let INDEX=${INDEX}+1
#          done < <(echo "$DOCKERFILES")
#          #cat $PROFILE_VALUES
#
#          #####################
#          # we want to take our custom $PROFILE_VALUES file and substitute it into the correct
#          # jupyterhub values.yaml spot through a series of edits
#          START_VALUES=values.yaml
#          NEW_VALUES=new-values.yaml
#
#          # find the existing empty "profileList" number
#          LINE_TO_DELETE=$(cat "$START_VALUES" | grep -n profileList | cut -d':' -f1)
#
#          # create $NEW_VALUES file with our custom $PROFILE_LIST file values by:
#          # 1) finding "/profileList/" in $START_VALUES file and get line number match
#          # 2) and insert everything from $PROFILE_VALUES file after that match line
#          sed -e '/profileList/r./'"$PROFILE_VALUES"'' $START_VALUES > $NEW_VALUES
#
#          # delete the first (and pre-existing) empty 'profileList' line
#          sed -i ''"$LINE_TO_DELETE"'d' $NEW_VALUES
#
#          # QC check in CI/CD runner
#          cat $NEW_VALUES | grep -B 15 -A 10 profileList
#
#          ######################
#          # helm render only the template we care about deploying which the daemonset
#          helm template -s templates/image-puller/daemonset-continuous.yaml . -f new-values.yaml > ../gitops-deploy/manifests.yaml
#
#          # QC check in CI/CD runner
#          cat ../gitops-deploy/manifests.yaml
#
#          # don't want github actions bot committing this
#          popd
#          rm -rf ./jupyterhub
#
#      - name: validate yaml manifest file
#        run: yamllint ../gitops-deploy/manifests.yaml
#
#      - name: commit ./gitops-deploy changes back
#        uses: EndBug/add-and-commit@v7
#        with:
#          default_author: github_actions
