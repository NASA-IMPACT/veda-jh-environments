name: docker-image-builder

on:
  push:
    branches:
      - main

jobs:
  build-docker-image:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: azure/setup-helm@v3

      - name: set git rev-parse head
        id: commitsha_head
        run: |
          TEMP=$(git rev-parse HEAD)
          echo "GIT_REV_HEAD=$TEMP" >> $GITHUB_OUTPUT

      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.DEPLOY_USER_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEPLOY_USER_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-1

      - name: docker build, tag, and push custom images
        env:
          ECR_REGISTRY_BASE: public.ecr.aws/i8x6m1u9/tf-pangeo-notebook-west1-sandbox
          ECR_REGISTRY_CUSTOM: public.ecr.aws/i8x6m1u9/tf-eis-feds-nrt-west1-sandbox
        run: |
          #####################
          # TODO: A) investigate using the kaniko github action here so it can manage state and not us
          # TODO: B) below is an example of what we want to do but we actually have to think about reop state more
          # future needs include:
          # 0) create a loop of images to iterate on, exclude pangeo-notebook
          # 1) get VERSION
          # 2) build images and tag with VERSION (also figure out how to add tags for sha256sum, GIT_REV_HEAD)
          # 3) query ECR to see if we have a repository with the folder name already (name of 'docker-images' > 'folders'), if not create
          # 4) query ECS repository to see if there exists an image in that repo with this ${{ steps.commitsha_head.outputs.GIT_REV_HEAD }} tag, if not create

#          # base pangeo-notebook image
#          pushd ./docker-images/pangeo-notebook
#          VERSION=$(cat Dockerfile | grep VERSION | cut -d'=' -f 2)
#          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws
#          docker build -t $ECR_REGISTRY_BASE:$VERSION .
#          docker push $ECR_REGISTRY_BASE:$VERSION
#          popd

          # custom pangeo-notebook image
          pushd ./docker-images/eis-feds-nrt
          VERSION=$(cat Dockerfile | grep VERSION | cut -d'=' -f 2)
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws
          docker build -t $ECR_REGISTRY_CUSTOM:$VERSION .
          docker push $ECR_REGISTRY_CUSTOM:$VERSION
          popd

      - name: download jupyterhub/jupyterhub helm version
        id: download_helm
        run: |
          #####################
          # this downloads the version of jupyterhub we already use on the k8s cluster
          # 1) untars it to ./jupyterhub directory
          # 2) exposes the templates we will need later to run individually and template manifests
          rm -rf ./jupyterhub
          helm repo add jupyterhub https://jupyterhub.github.io/helm-chart/
          helm pull jupyterhub/jupyterhub --version=2.0.0 --debug --untar

      - name: copy all dockerfiles to helm chart
        id: copydockerfiles
        run: |
          #####################
          # set up the downstream steps for helm
          rm -rf ./jupyterhub/dockerfile_inputs
          cp -r ./docker-images ./jupyterhub/dockerfile_inputs
          TEMP=$(ls -lah ./jupyterhub/dockerfile_inputs)
          echo $TEMP
#
      - name: find all dockerfiles && helm template manifest for daemon continuous-imagepuller
        id: valuesfile
        run: |
          #####################
          # get a list of all dockerfiles but the paths must be relative to the helm chart
          # and exclude the base images we don't want to use
          pushd ./jupyterhub
          DOCKERFILES=$(find dockerfile_inputs/* -name "Dockerfile" ! -path '*/pangeo-notebook/*' ! -path '*/custom-examples/*' -prune)

          #####################
          # build a small $PROFILE_VALUES file with our custom images we want to use
          PROFILE_VALUES=profilelist.yaml
          INDEX=0
          printf "  profileList:\n" >> $PROFILE_VALUES
          while read DOCKERFILE_PATH; do
            IMAGE_LOOKUP=$(cat $DOCKERFILE_PATH | grep FROM | cut -d' ' -f 2)
            VERSION=$(cat $DOCKERFILE_PATH | grep VERSION | cut -d'=' -f 2)
            NAME_AND_DESC=$(echo $DOCKERFILE_PATH | cut -d'/' -f 2)
            # TODO: what's the user experience for setting 'name', 'description', 'default'?
            printf "    - display-name: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
            printf "      description: $NAME_AND_DESC\n"  >> $PROFILE_VALUES
            printf "      kubespawner_override:\n"  >> $PROFILE_VALUES
            printf "        image: $IMAGE_LOOKUP\n"  >> $PROFILE_VALUES
            if [ $INDEX -eq 0 ]; then
            printf "      default: true\n"  >> $PROFILE_VALUES
            fi
            let INDEX=${INDEX}+1
          done < <(echo "$DOCKERFILES")
          #cat $PROFILE_VALUES

          #####################
          # we want to take our custom $PROFILE_VALUES file and substitute it into the correct
          # jupyterhub values.yaml spot through a series of edits
          START_VALUES=values.yaml
          NEW_VALUES=new-values.yaml
          # find the existing empty "profileList" number
          LINE_TO_DELETE=$(cat "$START_VALUES" | grep -n profileList | cut -d':' -f1)

          #####################
          # create $NEW_VALUES file with our custom $PROFILE_LIST file values by:
          # 1) finding "/profileList/" in $START_VALUES file and get line number match
          # 2) and insert everything from $PROFILE_VALUES file after that match line
          sed -e '/profileList/r./'"$PROFILE_VALUES"'' $START_VALUES > $NEW_VALUES
          # delete the first (and pre-existing) empty 'profileList' line
          sed -i ''"$LINE_TO_DELETE"'d' $NEW_VALUES
          # QC check in CI/CD runner
          cat $NEW_VALUES | grep -B 15 -A 10 profileList

          ######################
          # helm render only the template we care about deploying which the daemonset
          helm template -s templates/image-puller/daemonset-continuous.yaml . -f new-values.yaml > ../gitops-deploy/manifests.yaml
          cat ../gitops-deploy/manifests.yaml
          popd
          rm -rf ./jupyterhub

          ######################
          # TODO: add yaml validator step

      - name: commit ./gitops-deploy changes back
        uses: EndBug/add-and-commit@v7
        with:
          default_author: github_actions
